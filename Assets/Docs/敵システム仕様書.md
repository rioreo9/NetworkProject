# 敵システム仕様書（ステートマシン対応）

このドキュメントは、敵AIをステートマシン方式に刷新した設計仕様を示します。各挙動は「状態」単位の独立スクリプトで実装され、`EnemyAIBrainState` が現在状態の管理・遷移・更新を担当します。

## 📁 フォルダ構造

```
Enemy/
├── AI/
│   ├── EnemyAIBrainState.cs      # ステートマシン本体
│   └── States/                   # 具体ステート群（提案）
│       ├── EnemyIdleState.cs
│       ├── EnemyChaseState.cs
│       ├── EnemyAttackState.cs
│       └── EnemyDeadState.cs
├── Combat/
├── Core/
├── Spawning/
└── Types/
```

## 🏗️ アーキテクチャ概要

1. **BaseEnemy**: すべての敵の抽象基底。移動・攻撃APIと共通プロパティを提供
2. **EnemyAIBrainState**: ステートマシン。`IEnemyState` を保持しネットワーク権限下で更新
3. **IEnemyState + 具体ステート**: `Enter/Update/Exit` を実装する振る舞い単位のクラス
4. **WaveSpawner / EnemyCoordinator**: スポーンと撃破管理（従来通り）

```mermaid
classDiagram
direction LR

class BaseEnemy {
  <<abstract>>
  +bool IsAlive
  +float _moveSpeed
  +float _attackDamage
  +float _visionRange
  +float _attackRange
  +LayerMask _targetMask
  +void Initialize()*
  +void AttackTarget()*
  +void Death()
}

class EnemyAIBrainState {
  +AIState State
  -IEnemyState _current
  +void Initialize()
  +void TransitionTo(IEnemyState)
  +void FixedUpdateNetwork()
}

class IEnemyState {
  <<interface>>
  +void Enter()
  +void Update()
  +void Exit()
}

class EnemyIdleState
class EnemyChaseState
class EnemyAttackState
class EnemyDeadState

BaseEnemy <|.. EnemyWakame
EnemyAIBrainState ..> IEnemyState : holds
IEnemyState <|.. EnemyIdleState
IEnemyState <|.. EnemyChaseState
IEnemyState <|.. EnemyAttackState
IEnemyState <|.. EnemyDeadState
```

## 📋 コンポーネント仕様

### BaseEnemy（基底クラス）
**ファイル**: `Core/BaseEnemy.cs`

- Fusionの `NetworkBehaviour` を継承
- 主要プロパティ: `_maxHealth`, `_moveSpeed`, `_attackDamage`, `_visionRange`, `_attackRange`, `_targetMask`, `[Networked] IsAlive`
- ライフサイクル: `Spawned()` 内で `IsAlive=true`、`EnemyAIBrainState` 取得後に `Initialize()` を呼ぶ
- 抽象API: `Initialize()`, `AttackTarget()`

### EnemyAIBrainState（ステートマシン本体）
**ファイル**: `AI/EnemyAIBrainState.cs`

- `[Networked] AIState State { get; }` を公開（同期用の状態列挙）
- 内部に `IEnemyState _current` を保持し、権限側のみ `Update()` を呼ぶ
- 代表API

```csharp
public interface IEnemyState {
    void Enter();
    void Update();
    void Exit();
}

public sealed class EnemyAIBrainState : NetworkBehaviour {
    public enum AIState { Idle, Chase, Attack, Dead }

    [Networked] public AIState State { get; private set; }

    private IEnemyState _current;
    // 必要なら各ステートのインスタンスを生成・キャッシュ
    public IEnemyState Idle  { get; private set; }
    public IEnemyState Chase { get; private set; }
    public IEnemyState Attack{ get; private set; }
    public IEnemyState Dead  { get; private set; }

    public void Initialize() {
        // ステート生成・初期遷移
        State = AIState.Idle;
        TransitionTo(Idle);
    }

    public void TransitionTo(IEnemyState next) {
        if (_current == next) return;
        _current?.Exit();
        _current = next;
        _current?.Enter();
    }

    public override void FixedUpdateNetwork() {
        if (!HasStateAuthority) return;
        _current?.Update();
    }
}
```

### 具体ステート（例）

- 共通前提
  - それぞれ `EnemyAIBrainState` と `BaseEnemy` への参照を保持
  - 更新は `EnemyAIBrainState.FixedUpdateNetwork()` から呼ばれる
  - 遷移は `machine.TransitionTo(...)` を使用

- IdleState
  - 一定間隔で索敵（`_visionRange`、`_targetMask`）
  - 射程内: AttackState へ／視界内: ChaseState へ／ロスト: Idle継続

- ChaseState
  - ターゲットへ回頭して `_moveSpeed` で前進
  - 射程内なら AttackState、視界外なら IdleState へ

- AttackState
  - ターゲットへ回頭し `BaseEnemy.AttackTarget()` を呼ぶ
  - `TickTimer` で攻撃クールダウンを管理
  - 射程外で ChaseState へ

- DeadState
  - 入場時に移動/攻撃を停止。更新は基本なし

## 🔄 データフロー（更新）

```mermaid
sequenceDiagram
  participant Spawner as WaveSpawner
  participant Enemy as BaseEnemy/Types
  participant Brain as EnemyAIBrainState
  participant State as IEnemyState(各具体ステート)

  Spawner->>Enemy: Runner.Spawn(prefab)
  Enemy-->>Brain: GetComponent + Initialize()
  Brain->>State: TransitionTo(Idle)
  loop 権限側のTick
    Brain->>State: Update()
    State-->>Brain: TransitionTo(Chase/Attack/Dead) など
  end
```

## ⚡ ネットワーク方針

- ステート更新は `HasStateAuthority == true` のランナーのみ実行
- 表示に必要な軽量情報は `[Networked]` で同期（例: `AIState State`）
- 射撃などネットワークオブジェクト生成は `Runner.Spawn()` を使用

## 🧩 `EnemyWakame` との関係

- `EnemyWakame : BaseEnemy` は攻撃手段（弾生成）を提供
- AttackState 内から `owner.AttackTarget()` を呼び、`BulletMove` を `Runner.Spawn` する
- 例（抜粋）

```csharp
// EnemyWakame.AttackTarget()
var dir = (target.position - transform.position).normalized;
var bullet = Runner.Spawn(_bulletPrefab, transform.position + dir * 2, Quaternion.LookRotation(dir));
bullet.Init(dir);
```

## 🛠 実装ガイド

1. `AI/States/` を作成し、`IEnemyState` と各ステートを配置
2. `EnemyAIBrainState.Initialize()` で各ステートを生成し、初期遷移を実施
3. ステート内で `BaseEnemy` のAPI（移動・攻撃）を呼ぶ
4. 遷移条件は「距離」「視界」「生存」の3軸を基準に統一

## ✅ 完了条件（受け入れ基準）

- 状態は `Idle/Chase/Attack/Dead` の4種を最低限提供
- 権限側のみで `Update()` が実行されること
- `AIState` の値がクライアント間で同期されUI/デバッグで観測可能
- `EnemyWakame` が AttackState 経由で射撃できること

## 📌 参考：クラス命名ポリシー（敵タイプ）

- 機能ベース: `EnemyShooter`, `EnemyCharger`, `EnemyBomber`
- 行動+武器: `EnemyKelpShooter`（現`EnemyWakame`に近い）, `EnemyTurret`
- 階層を保つ場合は `Types/` 配下で `Enemy<Behavior>` に統一

---

作成日: 2024年／最終更新: ステートマシン方式に刷新