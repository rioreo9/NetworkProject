# æ•µã‚·ã‚¹ãƒ†ãƒ ä»•æ§˜æ›¸ï¼ˆã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³å¯¾å¿œï¼‰

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€æ•µAIã‚’ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³æ–¹å¼ã«åˆ·æ–°ã—ãŸè¨­è¨ˆä»•æ§˜ã‚’ç¤ºã—ã¾ã™ã€‚å„æŒ™å‹•ã¯ã€ŒçŠ¶æ…‹ã€å˜ä½ã®ç‹¬ç«‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§å®Ÿè£…ã•ã‚Œã€`EnemyAIBrainState` ãŒç¾åœ¨çŠ¶æ…‹ã®ç®¡ç†ãƒ»é·ç§»ãƒ»æ›´æ–°ã‚’æ‹…å½“ã—ã¾ã™ã€‚

## ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ 

```
Enemy/
â”œâ”€â”€ AI/
â”‚   â”œâ”€â”€ EnemyAIBrainState.cs      # ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³æœ¬ä½“
â”‚   â””â”€â”€ States/                   # å…·ä½“ã‚¹ãƒ†ãƒ¼ãƒˆç¾¤ï¼ˆææ¡ˆï¼‰
â”‚       â”œâ”€â”€ EnemyIdleState.cs
â”‚       â”œâ”€â”€ EnemyChaseState.cs
â”‚       â”œâ”€â”€ EnemyAttackState.cs
â”‚       â””â”€â”€ EnemyDeadState.cs
â”œâ”€â”€ Combat/
â”œâ”€â”€ Core/
â”œâ”€â”€ Spawning/
â””â”€â”€ Types/
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

1. **BaseEnemy**: ã™ã¹ã¦ã®æ•µã®æŠ½è±¡åŸºåº•ã€‚ç§»å‹•ãƒ»æ”»æ’ƒAPIã¨å…±é€šãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æä¾›
2. **EnemyAIBrainState**: ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã€‚`IEnemyState` ã‚’ä¿æŒã—ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¨©é™ä¸‹ã§æ›´æ–°
3. **IEnemyState + å…·ä½“ã‚¹ãƒ†ãƒ¼ãƒˆ**: `Enter/NetworkUpdate/Exit` ã‚’å®Ÿè£…ã™ã‚‹æŒ¯ã‚‹èˆã„å˜ä½ã®ã‚¯ãƒ©ã‚¹
4. **WaveSpawner / EnemyCoordinator**: ã‚¹ãƒãƒ¼ãƒ³ã¨æ’ƒç ´ç®¡ç†ï¼ˆå¾“æ¥é€šã‚Šï¼‰

```mermaid
classDiagram
direction LR

class BaseEnemy {
  <<abstract>>
  +bool IsAlive
  +float _moveSpeed
  +float _attackDamage
  +float _visionRange
  +float _attackRange
  +LayerMask _targetMask
  +void Initialize()*
  +void AttackTarget()*
  +void Death()
}

class EnemyAIBrainState {
  +AIState State
  -IEnemyState _current
  +void Initialize()
  +void TransitionTo(IEnemyState)
  +void FixedUpdateNetwork()
}

class IEnemyState {
  <<interface>>
  +void Enter()
  +void NetworkUpdate()
  +void Exit()
}

class EnemyIdleState
class EnemyChaseState
class EnemyAttackState
class EnemyDeadState

BaseEnemy <|.. EnemyShooter
EnemyAIBrainState ..> IEnemyState : holds
IEnemyState <|.. EnemyIdleState
IEnemyState <|.. EnemyChaseState
IEnemyState <|.. EnemyAttackState
IEnemyState <|.. EnemyDeadState
```

## ğŸ“‹ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä»•æ§˜

### BaseEnemyï¼ˆåŸºåº•ã‚¯ãƒ©ã‚¹ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Core/BaseEnemy.cs`

- Fusionã® `NetworkBehaviour` ã‚’ç¶™æ‰¿
- ä¸»è¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£: `_maxHealth`, `_moveSpeed`, `_attackDamage`, `_visionRange`, `_attackRange`, `_targetMask`, `[Networked] IsAlive`
- ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«: `Spawned()` å†…ã§ `IsAlive=true`ã€`EnemyAIBrainState` å–å¾—å¾Œã« `Initialize()` ã‚’å‘¼ã¶
- æŠ½è±¡API: `Initialize()`, `AttackTarget()`

### EnemyAIBrainStateï¼ˆã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³æœ¬ä½“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `AI/EnemyAIBrainState.cs`

- `[Networked] AIState State { get; }` ã‚’å…¬é–‹ï¼ˆåŒæœŸç”¨ã®çŠ¶æ…‹åˆ—æŒ™ï¼‰
- å†…éƒ¨ã« `IEnemyState _current` ã‚’ä¿æŒã—ã€æ¨©é™å´ã®ã¿ `NetworkUpdate()` ã‚’å‘¼ã¶
- ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»æ™‚ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ã¸é€šçŸ¥ã™ã‚‹ `OnStateChanged(AIState prev, AIState next)` ã‚’æä¾›
- ä»£è¡¨API

```csharp
public interface IEnemyState {
    void Enter();
    void NetworkUpdate();
    void Exit();
}

public sealed class EnemyAIBrainState : NetworkBehaviour {
    public enum AIState { Idle, Chase, Attack, Dead }

    [Networked] public AIState State { get; private set; }

    public event System.Action<AIState, AIState> OnStateChanged; // prev, next

    private IEnemyState _current;
    // å¿…è¦ãªã‚‰å„ã‚¹ãƒ†ãƒ¼ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    public IEnemyState Idle  { get; private set; }
    public IEnemyState Chase { get; private set; }
    public IEnemyState Attack{ get; private set; }
    public IEnemyState Dead  { get; private set; }

    public void Initialize() {
        // ã‚¹ãƒ†ãƒ¼ãƒˆç”Ÿæˆãƒ»åˆæœŸé·ç§»
        State = AIState.Idle;
        TransitionTo(Idle);
    }

    public void TransitionTo(IEnemyState next) {
        if (_current == next) return;
        // Exit/Enter ã¯åˆæœŸåŒ–ãƒ»å¾Œå§‹æœ«ã®ã¿è¡Œã†ï¼ˆé‡ã„å‡¦ç†ã‚„æ”»æ’ƒã¯ NetworkUpdate ã§å®Ÿæ–½ï¼‰
        _current?.Exit();
        _current = next;
        _current?.Enter();
    }

    public override void FixedUpdateNetwork() {
        if (!HasStateAuthority) return;
        _current?.NetworkUpdate();
    }
}
```

- Enter/Exit ãƒ«ãƒ¼ãƒ«
  - Enter/Exit ã¯ã€ŒåˆæœŸåŒ–ï¼å¾Œå§‹æœ«ã®ã¿ã€ã‚’è¡Œã†ã€‚ä¾‹: ã‚¿ã‚¤ãƒãƒ¼åˆæœŸåŒ–ã€ãƒ•ãƒ©ã‚°è¨­å®šã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡æ›¿è¦æ±‚
  - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”Ÿæˆãƒ»å¼¾ç™ºå°„ãƒ»ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šãªã©ã®æœ¬å‡¦ç†ã¯å¿…ãš `NetworkUpdate()` å†…ã§è¡Œã†
  - 1tick ã‚’è·¨ãå‡¦ç†ã¯ `NetworkUpdate()` ã§ç¶™ç¶šã•ã›ã‚‹

### å…·ä½“ã‚¹ãƒ†ãƒ¼ãƒˆï¼ˆä¾‹ï¼‰

- å…±é€šå‰æ
  - ãã‚Œãã‚Œ `EnemyAIBrainState` ã¨ `BaseEnemy` ã¸ã®å‚ç…§ã‚’ä¿æŒ
  - æ›´æ–°ã¯ `EnemyAIBrainState.FixedUpdateNetwork()` ã‹ã‚‰ `NetworkUpdate()` ãŒå‘¼ã°ã‚Œã‚‹
  - é·ç§»ã¯å„ã‚¹ãƒ†ãƒ¼ãƒˆã®å†…éƒ¨ãƒ­ã‚¸ãƒƒã‚¯ã‹ã‚‰ `machine.TransitionTo(...)` ã‚’å‘¼ã³å‡ºã—ã¦è¡Œã†ï¼ˆå›³ã® State.cs ãŒ Brain ã®çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹ï¼‰

- IdleState
  - ä¸€å®šé–“éš”ã§ç´¢æ•µï¼ˆ`_visionRange`ã€`_targetMask`ï¼‰
  - å°„ç¨‹å†…: AttackState ã¸ï¼è¦–ç•Œå†…: ChaseState ã¸ï¼ãƒ­ã‚¹ãƒˆ: Idleç¶™ç¶š

- ChaseState
  - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸å›é ­ã—ã¦ `_moveSpeed` ã§å‰é€²
  - å°„ç¨‹å†…ãªã‚‰ AttackStateã€è¦–ç•Œå¤–ãªã‚‰ IdleState ã¸

- AttackState
  - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸å›é ­ã— `BaseEnemy.AttackTarget()` ã‚’å‘¼ã¶
  - `TickTimer` ã§æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’ç®¡ç†
  - å°„ç¨‹å¤–ã§ ChaseState ã¸

- DeadState
  - å…¥å ´æ™‚ã«ç§»å‹•/æ”»æ’ƒã‚’åœæ­¢ã€‚æ›´æ–°ã¯åŸºæœ¬ãªã—

## ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ï¼ˆæ›´æ–°ï¼‰

```mermaid
sequenceDiagram
  participant Spawner as WaveSpawner
  participant Enemy as BaseEnemy/Types
  participant Brain as EnemyAIBrainState
  participant State as IEnemyState(å„å…·ä½“ã‚¹ãƒ†ãƒ¼ãƒˆ)
  participant Anim as EnemyAnimationController

  Spawner->>Enemy: Runner.Spawn(prefab)
  Enemy-->>Brain: GetComponent + Initialize()
  Brain->>State: TransitionTo(Idle)
  Brain-->>Anim: OnStateChanged(Idle)
  loop æ¨©é™å´ã®Tick
    Brain->>State: NetworkUpdate()
    State-->>Brain: TransitionTo(Chase/Attack/Dead) ãªã©
    Brain-->>Anim: OnStateChanged(prev, next)
  end
```

## âš¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–¹é‡

- ã‚¹ãƒ†ãƒ¼ãƒˆæ›´æ–°ã¯ `HasStateAuthority == true` ã®ãƒ©ãƒ³ãƒŠãƒ¼ã®ã¿å®Ÿè¡Œ
- è¡¨ç¤ºã«å¿…è¦ãªè»½é‡æƒ…å ±ã¯ `[Networked]` ã§åŒæœŸï¼ˆä¾‹: `AIState State`ï¼‰
- å°„æ’ƒãªã©ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆã¯ `Runner.Spawn()` ã‚’ä½¿ç”¨

## ğŸ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡

- ç›®çš„: ã‚¹ãƒ†ãƒ¼ãƒˆé·ç§»ã«å¿œã˜ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¸€å…ƒç®¡ç†
- ã‚¯ãƒ©ã‚¹: `EnemyAnimationController`ï¼ˆææ¡ˆã€‚`Animator` ã‚’ãƒ©ãƒƒãƒ—ï¼‰
- é…ç½®: æ•µãƒ—ãƒ¬ãƒãƒ–ã«ã‚¢ã‚¿ãƒƒãƒã—ã€`EnemyAIBrainState` ã‹ã‚‰é€šçŸ¥ã‚’å—ã‘ã‚‹
- é€£æºæ–¹æ³•
  - `EnemyAIBrainState` ã¯ `OnStateChanged(prev, next)` ã‚’ç™ºç«
  - `EnemyAnimationController` ã¯ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã¦ã€`next` ã«å¿œã˜ã¦ `PlayIdle/PlayRun/PlayAttack/PlayDie` ã‚’å‘¼ã¶
- ä»£è¡¨APIï¼ˆä¾‹ï¼‰

```csharp
public sealed class EnemyAnimationController : MonoBehaviour {
    [SerializeField] private Animator _animator;
    public void PlayIdle()   => _animator.Play("Idle");
    public void PlayRun()    => _animator.Play("Run");
    public void PlayAttack() => _animator.SetTrigger("Attack");
    public void PlayDie()    => _animator.Play("Die");
}

// Brain å´ï¼ˆTransitionToå†…ã‚„çŠ¶æ…‹å¤‰æ›´æ™‚ï¼‰
OnStateChanged?.Invoke(prev, next);
```

## ğŸ§© `EnemyWakame` â†’ æ–°åç§°ã§å†ä½œæˆ

- ç¾åœ¨ã® `EnemyWakame` ã¯åç§°ãŒä¸é©åˆ‡ãªãŸã‚å»ƒæ­¢ã—ã€æ©Ÿèƒ½ãƒ™ãƒ¼ã‚¹åã®æ–°ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
- æ–°ã‚¯ãƒ©ã‚¹åã®ææ¡ˆ: `EnemyShooter`ï¼ˆç›´ç·šå°„æ’ƒã«ç‰¹åŒ–ï¼‰
- ãƒ•ã‚¡ã‚¤ãƒ«: `Types/EnemyShooter.cs` ã‚’æ–°è¦ä½œæˆã—ã€`BaseEnemy` ã‚’ç¶™æ‰¿
- å½¹å‰²: å¼¾ç”Ÿæˆã¨å°„æ’ƒãƒ¬ãƒ¼ãƒˆç®¡ç†ã®ã¿ã‚’æ‹…å½“ï¼ˆè¡Œå‹•åˆ¤æ–­ã¯ã‚¹ãƒ†ãƒ¼ãƒˆå´ï¼‰
- ç§»è¡Œæ‰‹é †
  - `WaveConfiguration` ã§å‚ç…§ã—ã¦ã„ã‚‹ãƒ—ãƒ¬ãƒãƒ–ã‚’ `EnemyShooter` ã«å·®ã—æ›¿ãˆ
  - ã‚¹ãƒãƒ¼ãƒ³ç®‡æ‰€ï¼ˆ`WaveSpawner` ç­‰ï¼‰ã§ã®å‹ä¾å­˜ãŒã‚ã‚Œã° `BaseEnemy` ã«çµ±ä¸€
  - æ—§ `EnemyWakame` ã¯å‰Šé™¤ã¾ãŸã¯éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–

AttackState ã‹ã‚‰ `owner.AttackTarget()` ã‚’å‘¼ã³ã€`BulletMove` ã‚’ `Runner.Spawn` ã—ã¾ã™ï¼ˆæŠœç²‹ï¼‰ã€‚

```csharp
// EnemyWakame.AttackTarget()
var dir = (target.position - transform.position).normalized;
var bullet = Runner.Spawn(_bulletPrefab, transform.position + dir * 2, Quaternion.LookRotation(dir));
bullet.Init(dir);
```

## ğŸ›  å®Ÿè£…ã‚¬ã‚¤ãƒ‰

1. `AI/States/` ã‚’ä½œæˆã—ã€`IEnemyState` ã¨å„ã‚¹ãƒ†ãƒ¼ãƒˆã‚’é…ç½®
2. `EnemyAIBrainState.Initialize()` ã§å„ã‚¹ãƒ†ãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã€åˆæœŸé·ç§»ã‚’å®Ÿæ–½ï¼ˆEnter/Exit ã¯åˆæœŸåŒ–ãƒ»å¾Œå§‹æœ«ã®ã¿ï¼‰
3. ã‚¹ãƒ†ãƒ¼ãƒˆå†…ã§ `BaseEnemy` ã®APIï¼ˆç§»å‹•ãƒ»æ”»æ’ƒï¼‰ã‚’å‘¼ã¶
4. é·ç§»æ¡ä»¶ã¯ã€Œè·é›¢ã€ã€Œè¦–ç•Œã€ã€Œç”Ÿå­˜ã€ã®3è»¸ã‚’åŸºæº–ã«çµ±ä¸€ã—ã€ã‚¹ãƒ†ãƒ¼ãƒˆè‡ªèº«ãŒ `TransitionTo()` ã‚’å‘¼ã¶
5. `EnemyAnimationController` ã‚’é…ç½®ã—ã€`OnStateChanged` ã‚’è³¼èª­ã—ã¦ã‚¢ãƒ‹ãƒ¡å†ç”Ÿã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹

## âœ… å®Œäº†æ¡ä»¶ï¼ˆå—ã‘å…¥ã‚ŒåŸºæº–ï¼‰

- çŠ¶æ…‹ã¯ `Idle/Chase/Attack/Dead` ã®4ç¨®ã‚’æœ€ä½é™æä¾›
- æ¨©é™å´ã®ã¿ã§ `NetworkUpdate()` ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨
- `AIState` ã®å€¤ãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé–“ã§åŒæœŸã•ã‚ŒUI/ãƒ‡ãƒãƒƒã‚°ã§è¦³æ¸¬å¯èƒ½
- `EnemyWakame` ãŒ AttackState çµŒç”±ã§å°„æ’ƒã§ãã‚‹ã“ã¨

## ğŸ“Œ å‚è€ƒï¼šã‚¯ãƒ©ã‚¹å‘½åãƒãƒªã‚·ãƒ¼ï¼ˆæ•µã‚¿ã‚¤ãƒ—ï¼‰

- æ©Ÿèƒ½ãƒ™ãƒ¼ã‚¹: `EnemyShooter`, `EnemyCharger`, `EnemyBomber`
- è¡Œå‹•+æ­¦å™¨: `EnemyKelpShooter`ï¼ˆç¾`EnemyWakame`ã«è¿‘ã„ï¼‰, `EnemyTurret`
- éšå±¤ã‚’ä¿ã¤å ´åˆã¯ `Types/` é…ä¸‹ã§ `Enemy<Behavior>` ã«çµ±ä¸€

---

ä½œæˆæ—¥: 2024å¹´ï¼æœ€çµ‚æ›´æ–°: ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³æ–¹å¼ã«åˆ·æ–°